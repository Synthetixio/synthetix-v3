# Spot Market

This system generates synths (ERC-20 tokens) and markets that exchange them with stablecoins generated by [Synthetix](../../protocol/synthetix) at a price determined by the [oracle manager](../../protocol/oracle-manager) after applying fees.

To execute orders, the markets withdraw or deposit stablecoins with Synthetix (negatively or positively impacting the position of liquidity providers to the market, respectively). The market also reports the total supply of the synths multiplied by their current price (minus the value of the collateral provided to the market via the wrappers, if any) to Synthetix as debt, such that the synths are collateralized by liquidity providers in Synthetix. This amount is also locked, meaning that liquidity providers cannot remove delegated credit such that the issued synths would become undercollateralized.

## Creating Synths

To create a new synth and a corresponding market, call `registerSynth(string memory tokenName, string memory tokenSymbol, address marketOwner)`. This function returns a market ID, which can be used in a pool's configuration within Synthetix to provide
it with liquidity. The `getSynth(uint128 marketId)` function returns the address of the synth deployed for the specified market. The `marketOwner` address has the ability to configure price feeds and fees used by the market.

### Configuring Prices

The owner of a market may call `function updatePriceData(uint128 marketId, bytes32 buyNodeId, bytes32 sellNodeId)` to set the price feeds that should be used by the specified market. The node IDs must first be registered with the [oracle manager](../../protocol/oracle-manager).

### Configuring Fees

The owner of the market may set fees configurations using the functions exposed by the [IFeeConfigurationModule interface](./contracts/interfaces/IFeeConfigurationModule.sol).

## Types of Transactions

This market implementation allows synths to be exchanged using three different transaction types: atomic orders, asyncronous orders, and wrapping/unwrapping.

### Atomic Orders

The market allows traders to buy or sell synths in a single (atomic) transaction. The relevant logic is included in the [Atomic Order Module](./contracts/modules/AtomicOrderModule.sol).

To buy a synth in an atomic order, a trader may call `buy(uint128 marketId, uint usdAmount)` with the market ID for the synth they'd like to purchase and the amount of stablecoins they'd like to provide for the exchange. The trader must first approve the transfer of the amount of stablecoins to the market.

To sell a synth in an atomic order, a trader may call `sell(uint128 marketId, uint synthAmount)` with the market ID for the synth they'd like to sell and the amount of synths they'd like to provide for the exchange. The trader must first approve the transfer of the amount of synths to the market.

Traders may simulate calling these functions with `callStatic` to retrieve a quote of how much would have been provided in the exchange.

#### Fees

- `uint atomicFixedFee` - This fee (denominated as a percentage with 18 decimals) is applied to both buy and sell atomic orders.
- `mapping(address => uint) atomicFixedFeeOverrides` - This is a mapping of fees (denominated as a percentage with 18 decimals) that will be used instead of `atomicFixedFee` when `msg.sender` is found in the mapping.

### Asyncronous Orders

Asyncronous orders involve two transactions: a _commitment_ and a _settlement_. This reduces composability, but allows for front-running mitigation such that lower fees can be offered to traders. Asyncronous orders may be cancelled under certain circumstances. The relevant logic is included in the [Async Order Module](./contracts/modules/AsyncOrderModule.sol).

The market owner can configure various _settlement strategies_ for asyncronous orders. Each settlement strategy can be defined with the following properties:

- **Type** - There are three types of settlement strategies:
  - On-chain: Use the price provided by the oracle manager upon settlement
  - Chainlink: Use Chainlink-verifiable price data related to the settlement time.
  - Pyth: Use Pyth-verifiable price data related to the settlement time.
- **Fixed Fee**: This fee (denominated as a percentage with 18 decimals) is applied to both buy and sell asyncronous orders using this settlement strategy. (This is strongly recommended to mitigate front-running for on-chain settlements.)
- **Settlement Delay** - This is added to the timestamp associated with the block when the commitment is made to determine the settlement time. (This is strongly recommended to mitigate front-running for on-chain settlements.)
- **Settlement Window Duration** - The duration after the settlement time at which an order expires. If this is set to zero, asyncronous orders using this strategy never expire. (This is strongly recommended to mitigate trader optionality for on-chain settlements.)
- **Price Verification Contract**: For Chainlink and Pyth settlement strategies. _t.b.d._
- **Price Deviation Circuit Breaker Node ID** - For Chainlink and Pyth settlement strategies. _t.b.d._
- **Price Deviation Circuit Breaker Tolerance** - For Chainlink and Pyth settlement strategies. _t.b.d._

The following actions are involved with asyncronous orders:

- **Commit**
  - The trader deposits assets (stablecoins if buying or synths if selling) into escrow
  - The trader is issued an async order NFT that tracks: the order type (buy or sell), the amount escrowed, the settlement strategy to use, the settlement time, the estimated fill (to be factored into the utilization fee), and the estimated fee (to be used during cancellation).
- **Settle**
  - While in the settlement window, anyone can settle the order. Upon settlement, the holder of the async order NFT receives the assets in the exchange and the escrowed assets are burned (if synths) or deposited (if stablecoins). The price is determined differently based on the settlement strategy associated with the order:
    - On-chain: The price provided by the oracle manager at the time of the settle transaction is used, assuming that the timestamp associated with the price is greater than the settlement time.
    - Chainlink: The off-chain price data for the settlement time is used, assuming it is successfully verified by Chainlink and passes any configured circuit breaking checks.
    - Pyth: The off-chain price data for the settlement time is used, assuming it is successfully verified by Pyth and passes any configured circuit breaking checks.
- **Cancel**
  - The holder of the async order NFT may cancel the related order at any time. They receive the assets in escrow, after the fee calculated at the time of commitment is collected.
  - After the settlement window duration elapses, forcing the order into expiration, anyone can cancel the order. The holder of the relevant async order NFT receives the assets in escrow, minus the fee calculated at the time of commitment.
  - The market owner may cancel an order at any time. In this case, the holder of the relevant async order NFT receives the entire value of the assets in escrow (including the estimated fee).

#### Fees

The fixed fee associated with the settlement strategy is used for any given order.

### Wrapping

Markets which are able to [provide collateral directly to Synthetix](../../protocol/synthetix/contracts/modules/core/MarketCollateralModule.sol) can issue synths of equivalent value after applying fees. The relevant logic is included in the [Wrapper Module](./contracts/modules/WrapperModule.sol).

To wrap collateral and receive a synth, a trader may call `wrap(uint128 marketId, uint wrapAmount)` with the market ID relevant to the synth they'd like to wrap and the amount of collateral they'd like to provide for the exchange. The trader must first approve the transfer of the amount of collateral to the market.

To unwrap a synth and receive collateral, a trader may call `unwrap(uint128 marketId, uint unwrapAmount)` with the market ID relevant to the synth they'd like to unwrap and the amount of synths they'd like to provide for the exchange. The trader must first approve the transfer of the amount of synths to the market.

Traders may simulate calling these functions with `callStatic` to retrieve a quote of how much would have been provided in the exchange.

#### Fees

- `int wrapFixedFee` - This fee (denominated as a percentage with 18 decimals) is applied when collateral is wrapped and synths are issued. Note that this fee may be negative.
- `int unwrapFixedFee` - This fee (denominated as a percentage with 18 decimals) is applied when collateral is unwrapped and synths are burned. Note that this fee may be negative.

## Additional Fees and Configuration

In addition to the fees specific to transaction types outlined above, the following fees may be applied for different effects. Some or all of the fees may also be captured and distributed by a custom fee collector, rather than returned to liquidity providers directly.

### Supply Target Fee

A supply target fee helps limit liquidity providers' exposure to price fluctuations of the asset in situations where demand becomes very high. The amount of liquidity provided to a market implies a _supply target_. This is the ideal maximum amount of synths that the market would issue, where all of the credit capacity provided to the market were being utilized. This could expressed as a utilization rate of 100%.

If the utilization rate exceeds 100%, the market can apply a supply target fee on buy orders for atomic and asyncronous orders. The fee rate (configured as a percentage by the market owner with the `setMarketUtilizationFees()` function) is taken of the percentage by which the utilization rate exceeds 100% and applied to the order.

For instance, if a buy order would move the utilization rate from 90% to 120%, the average utilization rate resulting from the order would be 105%. This is a 5% excess. If the fee rate is set to 100%, a 5% fee is applied. If the fee rate is set to 50%, a 2.5% fee would be applied, etc.

### Simulated Slippage Fee

_t.c._

### Auto-Rebalancing Skew Fee

An auto-rebalancing skew fee allows a market to use wrapping functionality in such a way that reduces protocol risk. A (positive or negative) fee can be applied to buy and sell orders as a function of _market skew_, defined as the total supply of synths minus the amount of wrapped collateral. This creates an arbitrage opportunity that should reduce the skew.

The market owner can set the skew scale with the function `setMarketSkewScale()`. The skew scale is the amount we divide the current market skew by to determine the fee rate. For example, if a synthetic ETH market has issued 100 sETH and wrapped 110 ETH, the current skew would be -10 ETH. If the skew scale were set to 1,000 ETH, the skew fee would be -1% for a buy and 1% for a sell. This would incentivize users to buy more of the synth, reducing the skew.

### Custom Fee Collector

The owner of a market can deploy a custom fee collector contract (which conforms to the [IFeeCollector interface](./contracts/interfaces/external/IFeeCollector.sol)) and attach it to their market with the `setFeeCollector()` function.

When a custom fee collector has been set, after each transaction, the market will approve the value of the collected fees (as stablecoins) to be used by the fee collector contract and then call `collectFees()` on it. Any fees not transferred out of the market by this call will be deposited to liquidity providers in Synthetix per usual.

### Interest Rate

The owner of a market can set an interest rate (denominated as an annual percentage with 18 decimal places) for the synths issued by their market with the `setInterestRate()` function. This is implemented by making the synth a rebase token, where the total supply (and holders' individual balances) automatically decay at the specified rate.

Though synth decay may complicate composability, this incentivizes liquidity providers to back synths that tend to be held over long periods of time rather than actively exchanged.

## Development

`npm start`
